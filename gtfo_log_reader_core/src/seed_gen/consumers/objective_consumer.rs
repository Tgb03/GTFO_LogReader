use std::collections::VecDeque;

use serde::{Deserialize, Serialize};

use crate::{dll_exports::callback_handler::HasCallbackHandler, seed_gen::consumers::{base_consumer::Consumer, key_id_consumer::KeyIDConsumer}};



#[derive(Debug, Default, Clone, Serialize, Deserialize)]
pub struct ObjectiveConsumer {
    objectives_in_zones: VecDeque<Vec<KeyIDConsumer>>,

    #[serde(skip_serializing, default)]
    picked_zones: VecDeque<KeyIDConsumer>,
}

impl ObjectiveConsumer {

    fn calc_zone(&mut self, seed: f32) {
        if let Some(mut objectives_in_zone) = self.objectives_in_zones.pop_front() {
            let picked = (objectives_in_zone.len() as f32 * seed) as usize;
            self.picked_zones.push_back(objectives_in_zone.swap_remove(picked));
        }
    }

}

impl<O> Consumer<O> for ObjectiveConsumer
where
    O: HasCallbackHandler, {
        
    fn take(&mut self, seed: f32, output: &mut O) -> bool {
        if self.objectives_in_zones.len() > 0 {
            self.calc_zone(seed);
            return false;
        }

        if self.picked_zones.len() > 0 {
            self.picked_zones.pop_front()
                .map(|mut z| z.take(seed, output));
        }

        self.objectives_in_zones.is_empty() && self.picked_zones.is_empty()
    }

}

